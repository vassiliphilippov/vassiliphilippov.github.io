<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="style.css">
  <title>Search · Glite Dictionary</title>
</head>
<body>
  <div class="container">
<header>
  <h1>Search</h1>
  <p><a href="index.html">Back to Home</a></p>
</header>
<main>
  <input id="q" class="search" type="search" disabled
    placeholder="Loading search index...">
  <ul id="results" class="results" hidden></ul>
  <div id="history-section" hidden>
    <h3 style="margin-top: 1.5rem;">Search History</h3>
    <ul id="history" class="results"></ul>
  </div>
</main>
<script id="search-config" type="application/json">{"index":"search_index_v66_20251108T033526Z.jsonl","index_js":"search_index_v66_20251108T033526Z.js"}</script>
<style>
ul.results { list-style: none; padding: 0; margin-top: 8px;
             border: 1px solid #eaeaea; border-radius: 6px; }
ul.results li { padding: 10px 12px; border-bottom: 1px solid #f1f5f9;
                cursor: pointer; display: flex; justify-content: space-between; }
ul.results li:last-child { border-bottom: none; }
ul.results li.active { background: #f0f6ff; outline: 1px solid #c8e1ff; }
.result-main { display: flex; flex-direction: column; gap: 2px; }
.result-head { font-weight: 600; font-size: 1.05rem; line-height: 1.15; }
.result-sub { font-size: 0.95rem; color: #6b7280; line-height: 1.2; }
.result-count { font-size: 0.9rem; color: #6b7280; white-space: nowrap;
                margin-left: 12px; padding-top: 2px; }
</style>
<script>

(function(){
  var INDEX_HREF = 'search_index.jsonl';
  try {
    var cfg = document.getElementById('search-config');
    if (cfg && cfg.textContent) {
      var obj = JSON.parse(cfg.textContent);
      if (obj && typeof obj.index === 'string' && obj.index.length > 0) {
        INDEX_HREF = obj.index;
      }
      if (obj && typeof obj.index_js === 'string' && obj.index_js.length > 0) {
        window.__INDEX_JS__ = obj.index_js;
      }
    }
  } catch (e) {}
  if (!window.__INDEX_JS__ && typeof INDEX_HREF === 'string' && /\.jsonl$/i.test(INDEX_HREF)) {
    window.__INDEX_JS__ = INDEX_HREF.replace(/\.jsonl$/i, '.js');
  }
  const input = document.getElementById('q');
  const list = document.getElementById('results');
  const historySection = document.getElementById('history-section');
  const historyList = document.getElementById('history');

  /** @type {{h:string,u:string,p?:string[],m?:number,d?:number,f?:string,b?:string,c?:string,cl?:string}[]} */
  let INDEX = [];
  const maxItems = 80;
  let ACTIVE = -1;

  // Search history management
  const HISTORY_KEY = 'dictv3_search_history';
  const MAX_HISTORY = 10;

  function getHistory(){
    try {
      const raw = localStorage.getItem(HISTORY_KEY);
      if (raw) return JSON.parse(raw);
    } catch (e) {}
    return [];
  }

  function saveToHistory(item){
    try {
      let history = getHistory();
      history = history.filter(h => h.h !== item.h);
      history.unshift(item);
      history = history.slice(0, MAX_HISTORY);
      localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
    } catch (e) {}
  }

  function renderHistory(){
    const history = getHistory();
    if (history.length === 0){
      historySection.hidden = true;
      return;
    }
    historyList.innerHTML = '';
    for (const it of history){
      const li = document.createElement('li');
      const main = document.createElement('div');
      main.className = 'result-main';
      const head = document.createElement('span');
      head.className = 'result-head';
      head.textContent = it.h;
      const sub = document.createElement('span');
      sub.className = 'result-sub';
      const subText = posSummary(it.p || []);
      if (subText) sub.textContent = subText;
      main.appendChild(head);
      if (subText) main.appendChild(sub);
      const count = document.createElement('span');
      count.className = 'result-count';
      const m = Number(it.m || 0);
      if (m > 1) count.textContent = `${m} meanings`;
      li.appendChild(main);
      if (m > 1) li.appendChild(count);
      li.addEventListener('click', () => { window.location.href = it.u; });
      historyList.appendChild(li);
    }
    historySection.hidden = false;
  }

  function normalize(text){ 
    return (text || '').toLowerCase(); 
  }

  /**
   * Check if an index item is an inflected form (e.g., "cats" is inflected from "cat").
   * An item is inflected if it has a base form that differs from itself.
   */
  function isInflectedForm(item){
    if (!item.b) return false;
    const normalizedSurfaceForm = normalize(item.h);
    const normalizedBaseForm = normalize(item.b);
    return normalizedBaseForm !== normalizedSurfaceForm;
  }

  /**
   * Check if we should hide an inflected form from search results.
   * We hide inflections when their base form would match the query,
   * UNLESS the user is explicitly searching for that exact inflection.
   */
  function shouldHideInflection(item, query){
    if (!isInflectedForm(item)) {
      return false; // Not an inflection, never hide
    }
    
    const normalizedSurfaceForm = normalize(item.h);
    const normalizedBaseForm = normalize(item.b);
    const normalizedQuery = normalize(query);
    
    const isExactMatch = normalizedSurfaceForm === normalizedQuery;
    if (isExactMatch) {
      return false; // User is searching for this exact form, show it
    }
    
    const baseFormMatchesQuery = normalizedBaseForm.startsWith(normalizedQuery);
    return baseFormMatchesQuery; // Hide if base form matches query
  }

  /**
   * Calculate a search relevance score for an item.
   * Higher scores appear first in results.
   */
  function calculateRelevanceScore(item, query){
    const normalizedSurfaceForm = normalize(item.h);
    const normalizedQuery = normalize(query);
    
    // Exact match: highest priority
    if (normalizedSurfaceForm === normalizedQuery) {
      return 300;
    }
    
    // Starts with query: high priority
    // (but rank inflections lower than base forms)
    if (normalizedSurfaceForm.startsWith(normalizedQuery)) {
      return isInflectedForm(item) ? 150 : 200;
    }
    
    // Contains query: lower priority, penalize by position
    const matchPosition = normalizedSurfaceForm.indexOf(normalizedQuery);
    if (matchPosition !== -1) {
      return Math.max(1, 100 - matchPosition);
    }
    
    // No match
    return -1;
  }

  /**
   * Find and rank matching items for the search query.
   */
  function suggest(query){
    const trimmedQuery = query.trim();
    
    // Check for concept_id search (ct: prefix)
    if (trimmedQuery.startsWith('ct:')) {
      const conceptId = trimmedQuery.substring(3).trim();
      if (!conceptId) return [];
      const matches = [];
      for (const item of INDEX) {
        if (item.c && item.c.includes(conceptId)) {
          matches.push(item);
        }
      }
      return matches.slice(0, maxItems);
    }
    
    // Check for cluster_id search (cl: prefix)
    if (trimmedQuery.startsWith('cl:')) {
      const clusterId = trimmedQuery.substring(3).trim();
      if (!clusterId) return [];
      const matches = [];
      for (const item of INDEX) {
        if (item.cl && item.cl.includes(clusterId)) {
          matches.push(item);
        }
      }
      return matches.slice(0, maxItems);
    }
    
    const normalizedQuery = normalize(trimmedQuery);
    if (!normalizedQuery) {
      return [];
    }
    
    const scoredMatches = [];
    
    for (const item of INDEX){
      // Skip inflections when their base form matches
      // (e.g., skip "cats" when searching for "cat", unless searching for "cats" exactly)
      if (shouldHideInflection(item, normalizedQuery)) {
        continue;
      }
      
      const relevanceScore = calculateRelevanceScore(item, normalizedQuery);
      if (relevanceScore >= 0) {
        scoredMatches.push([relevanceScore, item]);
      }
    }
    
    // Sort by score (descending), then alphabetically by headword
    scoredMatches.sort((a, b) => {
      if (b[0] !== a[0]) return b[0] - a[0];
      return a[1].h.localeCompare(b[1].h);
    });
    
    // Return top results
    return scoredMatches.slice(0, maxItems).map(match => match[1]);
  }

  const POS_MAP = {
    'N': 'noun', 'NOUN': 'noun', 'PROPN': 'proper noun', 'PROPER_NOUN': 'proper noun',
    'ADJ': 'adjective', 'ADJECTIVE': 'adjective',
    'ADV': 'adverb', 'ADVERB': 'adverb',
    'V': 'verb', 'VERB': 'verb', 'AUX': 'auxiliary verb', 'PHRASAL_VERB': 'phrasal verb',
    'PRON': 'pronoun', 'PRONOUN': 'pronoun',
    'ADP': 'preposition', 'PREP': 'preposition', 'PREPOSITION': 'preposition',
    'CONJ': 'conjunction', 'CCONJ': 'conjunction', 'SCONJ': 'conjunction',
    'PART': 'particle', 'DET': 'determiner', 'DETERMINER': 'determiner',
    'NUM': 'numeral', 'NUMERAL': 'numeral', 'INTJ': 'interjection', 'INTERJECTION': 'interjection'
  };
  function friendlyPOS(pos){
    const t = (pos || '').trim().toUpperCase();
    return POS_MAP[t] || t.toLowerCase().replace(/_/g, ' ');
  }
  function posSummary(posList){
    if (!posList || !posList.length) return '';
    const uniq = Array.from(new Set(posList.map(friendlyPOS)));
    return uniq.join(' • ');
  }

  function render(items){
    list.innerHTML = '';
    if (!items.length){ list.hidden = true; ACTIVE = -1; return; }
    for (let i=0; i<items.length; i++){
      const it = items[i];
      const li = document.createElement('li');
      li.dataset.index = String(i);
      const main = document.createElement('div');
      main.className = 'result-main';
      const head = document.createElement('span');
      head.className = 'result-head';
      head.textContent = it.h;
      const sub = document.createElement('span');
      sub.className = 'result-sub';
      const subText = posSummary(it.p || []);
      if (subText) sub.textContent = subText;
      main.appendChild(head);
      if (subText) main.appendChild(sub);
      const right = document.createElement('span');
      right.className = 'result-count';
      const m = Number(it.m || 0);
      if (m > 1) {
        right.textContent = `${m} meanings`;
      } else if (typeof it.d === 'number' || typeof it.f === 'string') {
        const container = document.createElement('div');
        container.className = 'diff-freq-container';
        
        // Difficulty pill
        if (typeof it.d === 'number') {
          const diffPill = document.createElement('span');
          diffPill.className = 'diff-pill';
          let color = '#22c55e';
          if (it.d >= 4.0 && it.d < 7.0) color = '#f59e0b';
          if (it.d >= 7.0) color = '#ef4444';
          diffPill.style.setProperty('--diff-color', color);
          diffPill.textContent = it.d.toFixed(1);
          container.appendChild(diffPill);
        }
        
        // Frequency badge
        if (typeof it.f === 'string') {
          const freqBadge = document.createElement('span');
          freqBadge.className = 'freq-badge';
          freqBadge.textContent = it.f;
          container.appendChild(freqBadge);
        }
        
        right.textContent = '';
        right.appendChild(container);
      }
      li.appendChild(main);
      if (right.textContent || right.children.length) li.appendChild(right);
      li.addEventListener('click', () => { 
        saveToHistory(it);
        window.location.href = it.u; 
      });
      li.addEventListener('mousemove', () => setActive(i));
      list.appendChild(li);
    }
    list.hidden = false;
    ACTIVE = -1;
  }

  function setActive(i){
    const children = list.children;
    for (let j=0; j<children.length; j++){
      children[j].classList.toggle('active', j===i);
    }
    ACTIVE = i;
  }

  function openActiveOrFirst(){
    const items = Array.from(list.children);
    if (!items.length) return;
    const i = ACTIVE >= 0 ? ACTIVE : 0;
    const idx = Number(items[i].dataset.index || 0);
    const it = CURRENT[idx];
    if (it) {
      saveToHistory(it);
      window.location.href = it.u;
    }
  }

  let CURRENT = [];

  input.addEventListener('input', () => {
    const q = input.value;
    CURRENT = suggest(q);
    render(CURRENT);
    if (q.trim().length === 0){
      renderHistory();
    } else {
      historySection.hidden = true;
    }
  });

  input.addEventListener('keydown', (ev) => {
    if (ev.key === 'ArrowDown'){
      ev.preventDefault();
      if (list.hidden) return;
      const n = CURRENT.length; if (!n) return;
      setActive((ACTIVE + 1) + 0 >= n ? 0 : ACTIVE + 1);
    } else if (ev.key === 'ArrowUp'){
      ev.preventDefault();
      if (list.hidden) return;
      const n = CURRENT.length; if (!n) return;
      setActive((ACTIVE - 1 + n) % n);
    } else if (ev.key === 'Enter'){
      if (!list.hidden){ ev.preventDefault(); openActiveOrFirst(); }
    }
  });

  async function loadIndex(){
    if (Array.isArray(window.SEARCH_INDEX)) {
      return window.SEARCH_INDEX;
    }
    // Prefer external NDJSON file
    try {
      const res = await fetch(INDEX_HREF, {cache: 'no-store'});
      if (res.ok){
        const text = await res.text();
        const lines = text.split(/\r?\n/);
        const arr = [];
        for (const line of lines){
          const t = line.trim();
          if (t.length === 0) continue;
          try { arr.push(JSON.parse(t)); } catch {}
        }
        return arr;
      }
    } catch (e) {}
    // Fallback: embedded script for file:// usage
    try {
      // If a JS index is available, load it first
      if (window.__INDEX_JS__) {
        await new Promise((resolve) => {
          var s = document.createElement('script');
          s.src = window.__INDEX_JS__;
          s.onload = resolve; s.onerror = resolve;
          document.head.appendChild(s);
        });
        if (Array.isArray(window.SEARCH_INDEX)) return window.SEARCH_INDEX;
      }
      const embedded = document.getElementById('embedded-index');
      if (embedded && embedded.textContent){
        const text = embedded.textContent;
        // Support either JSON array or NDJSON lines
        const trimmed = text.trim();
        if (trimmed.startsWith('[')){
          return JSON.parse(trimmed);
        }
        const lines = trimmed.split(/\r?\n/);
        const arr = [];
        for (const line of lines){
          const t = line.trim();
          if (t.length === 0) continue;
          try { arr.push(JSON.parse(t)); } catch {}
        }
        return arr;
      }
    } catch (e) {}
    return [];
  }

  // Load the index, then enable search
  loadIndex().then(arr => {
    if (Array.isArray(arr)) {
      INDEX = arr;
      input.disabled = false;
      input.placeholder = 'Search surface forms… (e.g., ran, runners, take off)';
      input.focus();
      const val = (input.value || '').trim();
      if (val.length > 0){
        CURRENT = suggest(val);
        render(CURRENT);
      } else {
        renderHistory();
      }
    }
  });

  // Handle back button navigation: clear search and refocus
  window.addEventListener('pageshow', function(event) {
    // event.persisted is true when page is loaded from bfcache (back/forward cache)
    if (event.persisted) {
      input.value = '';
      CURRENT = [];
      render(CURRENT);
      renderHistory();
      if (!input.disabled) {
        input.focus();
      }
    }
  });
})();

</script>
  </div>
</body>
</html>
