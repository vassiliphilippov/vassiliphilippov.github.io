<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="style.css">
  <title>Search Â· Glite Dictionary</title>
</head>
<body>
  <div class="container">
<header>
  <h1>Search</h1>
  <p><a href="index.html">Back to Home</a></p>
</header>
<main>
  <input id="q" class="search" type="search" disabled
    placeholder="Loading search index...">
  <ul id="results" class="results" hidden></ul>
  <div id="history-section" hidden>
    <h3 style="margin-top: 1.5rem;">Search History</h3>
    <ul id="history" class="results"></ul>
  </div>
</main>
<script id="search-config" type="application/json">{"index":"search_index_v82_20251109T023215Z.jsonl","index_js":"search_index_v82_20251109T023215Z.js"}</script>
<style>
ul.results { list-style: none; padding: 0; margin-top: 8px;
             border: 1px solid #eaeaea; border-radius: 6px; }
ul.results li { padding: 10px 12px; border-bottom: 1px solid #f1f5f9;
                cursor: pointer; display: flex; justify-content: space-between; }
ul.results li:last-child { border-bottom: none; }
ul.results li.active { background: #f0f6ff; outline: 1px solid #c8e1ff; }
.result-main { display: flex; flex-direction: column; gap: 2px; }
.result-head { font-weight: 600; font-size: 1.05rem; line-height: 1.15; }
.result-sub { font-size: 0.95rem; color: #6b7280; line-height: 1.2; }
.result-count { font-size: 0.9rem; color: #6b7280; white-space: nowrap;
                margin-left: 12px; padding-top: 2px; }
</style>
<script>

(function(){
  var INDEX_HREF = 'search_index.jsonl';
  try {
    var cfg = document.getElementById('search-config');
    if (cfg && cfg.textContent) {
      var obj = JSON.parse(cfg.textContent);
      if (obj && typeof obj.index === 'string' && obj.index.length > 0) {
        INDEX_HREF = obj.index;
      }
      if (obj && typeof obj.index_js === 'string' && obj.index_js.length > 0) {
        window.__INDEX_JS__ = obj.index_js;
      }
    }
  } catch (e) {}
  if (!window.__INDEX_JS__ && typeof INDEX_HREF === 'string' && /\.jsonl$/i.test(INDEX_HREF)) {
    window.__INDEX_JS__ = INDEX_HREF.replace(/\.jsonl$/i, '.js');
  }
  const input = document.getElementById('q');
  const list = document.getElementById('results');
  const historySection = document.getElementById('history-section');
  const historyList = document.getElementById('history');

  /** @type {{h:string,u:string,p?:string[],m?:number,d?:number,f_num?:number,is_inflected?:boolean,b?:string,c?:string,cl?:string}[]} */
  let INDEX = [];
  const maxItems = 80;
  let ACTIVE = -1;

  // Performance tracking
  const PERF = {
    loadStart: performance.now(),
    loadEnd: 0,
    indexSize: 0,
    firstSearchStart: 0,
    firstSearchEnd: 0,
  };

  // Search history management
  const HISTORY_KEY = 'dictv3_search_history';
  const MAX_HISTORY = 10;

  function getHistory(){
    try {
      const raw = localStorage.getItem(HISTORY_KEY);
      if (raw) return JSON.parse(raw);
    } catch (e) {}
    return [];
  }

  function saveToHistory(item){
    try {
      let history = getHistory();
      history = history.filter(h => h.h !== item.h);
      history.unshift(item);
      history = history.slice(0, MAX_HISTORY);
      localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
    } catch (e) {}
  }

  function renderHistory(){
    const history = getHistory();
    if (history.length === 0){
      historySection.hidden = true;
      return;
    }
    historyList.innerHTML = '';
    for (const it of history){
      const li = document.createElement('li');
      const main = document.createElement('div');
      main.className = 'result-main';
      const head = document.createElement('span');
      head.className = 'result-head';
      head.textContent = it.h;
      const sub = document.createElement('span');
      sub.className = 'result-sub';
      // Reconstruct POS display from p array (also works with history items)
      const subText = it.p_display || posSummary(it.p || []);
      if (subText) sub.textContent = subText;
      main.appendChild(head);
      if (subText) main.appendChild(sub);
      const count = document.createElement('span');
      count.className = 'result-count';
      const m = Number(it.m || 0);
      if (m > 1) count.textContent = `${m} meanings`;
      li.appendChild(main);
      if (m > 1) li.appendChild(count);
      li.addEventListener('click', () => { window.location.href = it.u; });
      historyList.appendChild(li);
    }
    historySection.hidden = false;
  }

  function normalize(text){ 
    return (text || '').toLowerCase(); 
  }

  /**
   * Check if an index item is an inflected form (e.g., "cats" is inflected from "cat").
   * OPTIMIZATION: Uses precomputed is_inflected flag from Python to avoid normalization.
   */
  function isInflectedForm(item){
    // Use precomputed value if available (faster)
    if (item.is_inflected !== undefined && item.is_inflected !== null) {
      return item.is_inflected;
    }
    // Fallback for backwards compatibility (should not happen with new index)
    if (!item.b) return false;
    const normalizedSurfaceForm = normalize(item.h);
    const normalizedBaseForm = normalize(item.b);
    return normalizedBaseForm !== normalizedSurfaceForm;
  }

  /**
   * Check if we should hide an inflected form from search results.
   * We hide inflections when their base form is PRESENT in the results,
   * UNLESS the user is explicitly searching for that exact inflection.
   * 
   * @param {object} item - The search index item to check
   * @param {string} query - The normalized search query
   * @param {Set<string>} baseFormsInResults - Set of base forms present in results
   */
  function shouldHideInflection(item, query, baseFormsInResults){
    if (!isInflectedForm(item)) {
      return false; // Not an inflection, never hide
    }
    
    const normalizedSurfaceForm = normalize(item.h);
    const normalizedQuery = normalize(query);
    
    // If user is searching for this exact form, always show it
    const isExactMatch = normalizedSurfaceForm === normalizedQuery;
    if (isExactMatch) {
      return false;
    }
    
    // Hide inflection if its base form is present in the search results
    const normalizedBaseForm = normalize(item.b);
    return baseFormsInResults.has(normalizedBaseForm);
  }

  /**
   * Calculate a search relevance score for an item.
   * Higher scores appear first in results.
   */
  function calculateRelevanceScore(item, query){
    const normalizedSurfaceForm = normalize(item.h);
    const normalizedQuery = normalize(query);
    
    // Exact match: highest priority
    if (normalizedSurfaceForm === normalizedQuery) {
      return 300;
    }
    
    // Starts with query: high priority
    // (but rank inflections lower than base forms)
    if (normalizedSurfaceForm.startsWith(normalizedQuery)) {
      return isInflectedForm(item) ? 150 : 200;
    }
    
    // Contains query: lower priority, penalize by position
    const matchPosition = normalizedSurfaceForm.indexOf(normalizedQuery);
    if (matchPosition !== -1) {
      return Math.max(1, 100 - matchPosition);
    }
    
    // No match
    return -1;
  }


  /**
   * Find and rank matching items for the search query.
   */
  function suggest(query){
    // Track first search performance
    if (PERF.firstSearchStart === 0) {
      PERF.firstSearchStart = performance.now();
    }
    
    const trimmedQuery = query.trim();
    
    // Check for concept_id search (ct: prefix)
    if (trimmedQuery.startsWith('ct:')) {
      const conceptId = trimmedQuery.substring(3).trim();
      if (!conceptId) return [];
      const matches = [];
      for (const item of INDEX) {
        if (item.c && item.c.includes(conceptId)) {
          matches.push(item);
        }
      }
      return matches.slice(0, maxItems);
    }
    
    // Check for cluster_id search (cl: prefix)
    if (trimmedQuery.startsWith('cl:')) {
      const clusterId = trimmedQuery.substring(3).trim();
      if (!clusterId) return [];
      const matches = [];
      for (const item of INDEX) {
        if (item.cl && item.cl.includes(clusterId)) {
          matches.push(item);
        }
      }
      return matches.slice(0, maxItems);
    }
    
    const normalizedQuery = normalize(trimmedQuery);
    if (!normalizedQuery) {
      return [];
    }
    
    // PASS 1: Collect all matching items (before inflection filtering)
    const scoredMatches = [];
    
    for (const item of INDEX){
      const relevanceScore = calculateRelevanceScore(item, normalizedQuery);
      if (relevanceScore >= 0) {
        scoredMatches.push([relevanceScore, item]);
      }
    }
    
    // Build set of all base forms (headwords) present in the initial results
    // This is used to filter out inflections when their base form is available
    const baseFormsInResults = new Set();
    for (const [score, item] of scoredMatches) {
      const normalizedHeadword = normalize(item.h);
      baseFormsInResults.add(normalizedHeadword);
    }
    
    // PASS 2: Filter out inflections whose base forms are in the results
    // (e.g., hide "cats" if "cat" is present, unless user searched for "cats" exactly)
    const filteredMatches = [];
    for (const [score, item] of scoredMatches) {
      if (!shouldHideInflection(item, normalizedQuery, baseFormsInResults)) {
        filteredMatches.push([score, item]);
      }
    }
    
    // Sort filtered results by score (descending), then by frequency (descending), then alphabetically
    filteredMatches.sort((a, b) => {
      // First: relevance score (higher is better)
      if (b[0] !== a[0]) return b[0] - a[0];
      
      // Second: frequency (higher is better) - use pre-parsed numeric value
      const freqA = a[1].f_num || 0;
      const freqB = b[1].f_num || 0;
      if (freqB !== freqA) return freqB - freqA;
      
      // Third: alphabetically
      return a[1].h.localeCompare(b[1].h);
    });
    
    // Return top results
    const results = filteredMatches.slice(0, maxItems).map(match => match[1]);
    
    // Track first search completion
    if (PERF.firstSearchStart > 0 && PERF.firstSearchEnd === 0) {
      PERF.firstSearchEnd = performance.now();
      const searchTime = PERF.firstSearchEnd - PERF.firstSearchStart;
      console.log(`[Search Performance] First search completed in ${searchTime.toFixed(2)}ms`);
    }
    
    return results;
  }

  /**
   * Reconstruct frequency display string from numeric value.
   * Reduces index size by ~3-5% by not storing redundant string.
   */
  function formatFrequency(f_num){
    if (!f_num || typeof f_num !== 'number') return null;
    return f_num + '/m';
  }

  /**
   * Get difficulty color from numeric difficulty score.
   * Reduces index size by not storing redundant hex colors.
   */
  function getDifficultyColor(difficulty){
    if (typeof difficulty !== 'number') return '#22c55e';
    if (difficulty >= 7.0) return '#ef4444';  // red
    if (difficulty >= 4.0) return '#f59e0b';  // orange
    return '#22c55e';  // green
  }

  const POS_MAP = {
    'N': 'noun', 'NOUN': 'noun', 'PROPN': 'proper noun', 'PROPER_NOUN': 'proper noun',
    'ADJ': 'adjective', 'ADJECTIVE': 'adjective',
    'ADV': 'adverb', 'ADVERB': 'adverb',
    'V': 'verb', 'VERB': 'verb', 'AUX': 'auxiliary verb', 'PHRASAL_VERB': 'phrasal verb',
    'PRON': 'pronoun', 'PRONOUN': 'pronoun',
    'ADP': 'preposition', 'PREP': 'preposition', 'PREPOSITION': 'preposition',
    'CONJ': 'conjunction', 'CCONJ': 'conjunction', 'SCONJ': 'conjunction',
    'PART': 'particle', 'DET': 'determiner', 'DETERMINER': 'determiner',
    'NUM': 'numeral', 'NUMERAL': 'numeral', 'INTJ': 'interjection', 'INTERJECTION': 'interjection'
  };
  function friendlyPOS(pos){
    const t = (pos || '').trim().toUpperCase();
    return POS_MAP[t] || t.toLowerCase().replace(/_/g, ' ');
  }
  function posSummary(posList){
    if (!posList || !posList.length) return '';
    const uniq = Array.from(new Set(posList.map(friendlyPOS)));
    return uniq.join(' â€¢ ');
  }

  function render(items){
    list.innerHTML = '';
    if (!items.length){ list.hidden = true; ACTIVE = -1; return; }
    for (let i=0; i<items.length; i++){
      const it = items[i];
      const li = document.createElement('li');
      li.dataset.index = String(i);
      const main = document.createElement('div');
      main.className = 'result-main';
      const head = document.createElement('span');
      head.className = 'result-head';
      head.textContent = it.h;
      const sub = document.createElement('span');
      sub.className = 'result-sub';
      // Reconstruct POS display from p array (or use cached p_display if present)
      const subText = it.p_display || posSummary(it.p || []);
      if (subText) sub.textContent = subText;
      main.appendChild(head);
      if (subText) main.appendChild(sub);
      const right = document.createElement('span');
      right.className = 'result-count';
      const m = Number(it.m || 0);
      if (m > 1) {
        right.textContent = `${m} meanings`;
      } else if (typeof it.d === 'number' || typeof it.f_num === 'number') {
        const container = document.createElement('div');
        container.className = 'diff-freq-container';
        
        // Difficulty pill
        if (typeof it.d === 'number') {
          const diffPill = document.createElement('span');
          diffPill.className = 'diff-pill';
          // Reconstruct color from difficulty (or use cached d_color if present)
          const color = it.d_color || getDifficultyColor(it.d);
          diffPill.style.setProperty('--diff-color', color);
          diffPill.textContent = it.d.toFixed(1);
          container.appendChild(diffPill);
        }
        
        // Frequency badge
        if (typeof it.f_num === 'number') {
          const freqBadge = document.createElement('span');
          freqBadge.className = 'freq-badge';
          // Reconstruct frequency string from f_num (or use cached f if present)
          const freqText = it.f || formatFrequency(it.f_num);
          if (freqText) {
            freqBadge.textContent = freqText;
            container.appendChild(freqBadge);
          }
        }
        
        right.textContent = '';
        right.appendChild(container);
      }
      li.appendChild(main);
      if (right.textContent || right.children.length) li.appendChild(right);
      li.addEventListener('click', () => { 
        saveToHistory(it);
        window.location.href = it.u; 
      });
      li.addEventListener('mousemove', () => setActive(i));
      list.appendChild(li);
    }
    list.hidden = false;
    ACTIVE = -1;
  }

  function setActive(i){
    const children = list.children;
    for (let j=0; j<children.length; j++){
      children[j].classList.toggle('active', j===i);
    }
    ACTIVE = i;
  }

  function openActiveOrFirst(){
    const items = Array.from(list.children);
    if (!items.length) return;
    const i = ACTIVE >= 0 ? ACTIVE : 0;
    const idx = Number(items[i].dataset.index || 0);
    const it = CURRENT[idx];
    if (it) {
      saveToHistory(it);
      window.location.href = it.u;
    }
  }

  let CURRENT = [];

  input.addEventListener('input', () => {
    const q = input.value;
    CURRENT = suggest(q);
    render(CURRENT);
    if (q.trim().length === 0){
      renderHistory();
    } else {
      historySection.hidden = true;
    }
  });

  input.addEventListener('keydown', (ev) => {
    if (ev.key === 'ArrowDown'){
      ev.preventDefault();
      if (list.hidden) return;
      const n = CURRENT.length; if (!n) return;
      setActive((ACTIVE + 1) + 0 >= n ? 0 : ACTIVE + 1);
    } else if (ev.key === 'ArrowUp'){
      ev.preventDefault();
      if (list.hidden) return;
      const n = CURRENT.length; if (!n) return;
      setActive((ACTIVE - 1 + n) % n);
    } else if (ev.key === 'Enter'){
      if (!list.hidden){ ev.preventDefault(); openActiveOrFirst(); }
    }
  });

  async function loadIndex(){
    if (Array.isArray(window.SEARCH_INDEX)) {
      return window.SEARCH_INDEX;
    }
    // Prefer external NDJSON file
    try {
      const res = await fetch(INDEX_HREF, {cache: 'no-store'});
      if (res.ok){
        const text = await res.text();
        const lines = text.split(/\r?\n/);
        const arr = [];
        for (const line of lines){
          const t = line.trim();
          if (t.length === 0) continue;
          try { arr.push(JSON.parse(t)); } catch {}
        }
        return arr;
      }
    } catch (e) {}
    // Fallback: embedded script for file:// usage
    try {
      // If a JS index is available, load it first
      if (window.__INDEX_JS__) {
        await new Promise((resolve) => {
          var s = document.createElement('script');
          s.src = window.__INDEX_JS__;
          s.onload = resolve; s.onerror = resolve;
          document.head.appendChild(s);
        });
        if (Array.isArray(window.SEARCH_INDEX)) return window.SEARCH_INDEX;
      }
      const embedded = document.getElementById('embedded-index');
      if (embedded && embedded.textContent){
        const text = embedded.textContent;
        // Support either JSON array or NDJSON lines
        const trimmed = text.trim();
        if (trimmed.startsWith('[')){
          return JSON.parse(trimmed);
        }
        const lines = trimmed.split(/\r?\n/);
        const arr = [];
        for (const line of lines){
          const t = line.trim();
          if (t.length === 0) continue;
          try { arr.push(JSON.parse(t)); } catch {}
        }
        return arr;
      }
    } catch (e) {}
    return [];
  }

  // Load the index, then enable search
  loadIndex().then(arr => {
    if (Array.isArray(arr)) {
      PERF.loadEnd = performance.now();
      PERF.indexSize = arr.length;
      
      INDEX = arr;
      
      // Log loading performance
      const loadTime = PERF.loadEnd - PERF.loadStart;
      let indexSizeKB = 'N/A';
      try {
        indexSizeKB = (JSON.stringify(arr).length / 1024).toFixed(2);
      } catch (e) {
        // In case serialization fails for very large indexes
      }
      
      // Check which precomputed fields are present
      const sampleRecord = arr.length > 0 ? arr[0] : {};
      const hasPrecomputed = {
        f_num: 'f_num' in sampleRecord,
        is_inflected: 'is_inflected' in sampleRecord,
      };
      const precomputedCount = Object.values(hasPrecomputed).filter(Boolean).length;
      
      console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
      console.log('ðŸ“Š SEARCH INDEX LOADING PERFORMANCE');
      console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
      console.log(`â±ï¸  Load time: ${loadTime.toFixed(2)}ms`);
      console.log(`ðŸ“¦ Index size: ${PERF.indexSize.toLocaleString()} records`);
      console.log(`ðŸ’¾ Data size: ${indexSizeKB} KB`);
      console.log(`âš¡ Records/ms: ${(PERF.indexSize / loadTime).toFixed(2)}`);
      console.log(`ðŸš€ Precomputed fields: ${precomputedCount}/2 (f_num, is_inflected)`);
      console.log(`ðŸ“‰ Size optimized: removed f, p_display, d_color (~5% savings)`);
      console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
      
      input.disabled = false;
      input.placeholder = 'Search surface formsâ€¦ (e.g., ran, runners, take off)';
      input.focus();
      const val = (input.value || '').trim();
      if (val.length > 0){
        CURRENT = suggest(val);
        render(CURRENT);
      } else {
        renderHistory();
      }
    }
  });

  // Handle back button navigation: clear search and refocus
  window.addEventListener('pageshow', function(event) {
    // event.persisted is true when page is loaded from bfcache (back/forward cache)
    if (event.persisted) {
      input.value = '';
      CURRENT = [];
      render(CURRENT);
      renderHistory();
      if (!input.disabled) {
        input.focus();
      }
    }
  });
})();

</script>
  </div>
</body>
</html>
